<!DOCTYPE html>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/utils.js"></script>
<script src="/common/dispatcher/dispatcher.js"></script>
<script src="/common/get-host-info.sub.js"></script>
<script src="resources/utils.js"></script>
<title>Test fenced frame null config installation triggers about:blank navigation.</title>

<body>

  <script>
    promise_test(async (t) => {
      var frame_context = attachFencedFrameContext();

      // Ensure remote context responds.
      for (let i = 0; i < 3; i++) {
        let value = await Promise.any([
          frame_context.execute(() => 'alive'),
          new Promise(resolve => t.step_timeout(
            () => resolve('timed_out'), 3000))
        ]);
        assert_equals(value, 'alive');
      }

      // Should trigger navigation, removing the FencedFrame's portion of the
      // remote context.
      frame_context.element.config = null;

      // None of these calls should succeed, because we should have navigated to
      // about:blank, and the RemoteContext's embedded handler code should be
      // gone. Note that because the code has been deleted, we can't actually
      // inspect the URL to determine it is about:blank; we have to use our
      // timeout as a proxy.
      for (let i = 0; i < 3; i++) {
        let value = await Promise.any([
          frame_context.execute(() => 'alive'),
          new Promise(resolve => t.step_timeout(
            () => resolve('timed_out'), 3000))
        ]);
        assert_equals(value, 'timed_out');
      }
    }, "Test that a fenced frame with a config explicitly set to null navigates to about:blank");
  </script>

</body>
